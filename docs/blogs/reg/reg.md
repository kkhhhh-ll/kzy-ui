正则表达式是匹配模式，要不字符匹配，要不位置匹配。

## 字符匹配

### 精确匹配

精确匹配是匹配特定字符或字符串，比如`/abc/`就是匹配字符串 `abc`。

### 模糊匹配

模糊匹配，分为横向模糊匹配和纵向模糊匹配。

#### 横向模糊匹配

比如 `/ab{1,3}c/`，匹配的字符串中可以含有 1 到 3 个 b，这里的横向可以简单理解为字符串变长了，可以匹配 `abc`、`abbc`、`abbbc`。

#### 纵向模糊匹配

纵向模糊匹配借助了字符组([])的能力来实现，比如`/a[123]b/`，表示在第二个位置可以有 `1、2、3` 这三个的任意一个值，简单理解就是字符串长度不变，但是在指定位置可以有多种情况。

### 字符组

字符组是用`[]`包裹起来的一组字符，表示指定位置可以是这组字符中的任意一个字符。

#### 常见简写

`/\d/`--匹配所有的数字，等同于`[0-9]`。<br>
`/\D/`--匹配除数字外的所有字符，等同于`[^0-9]`。<br>
`/\w/`--匹配数字，字母，下划线，等同于`[0-9a-zA-Z_]`。<br>
`/\W/`--匹配数字，字母，下划线之外的其他字符，等同于`[^0-9a-zA-Z_]`。<br>
`/\s/`--匹配空白字符。<br>
`/\S/`--匹配空白字符之外的其他字符。<br>
`任意字符`--`[\d\D]`、`[\w\W]`、`[\s\S]`。<br>

### 量词

量词也称重复，即重复匹配量词前面的表达式，比如横向模糊匹配中的/ab{1,3}c/，表示重复匹配 b 一到三次。

#### 常见简写

`{m}`--重复匹配至少 m 次。<br>
`{m, n}`--重复匹配至少 m 次，最多 n 次。<br>
`？`--重复匹配一次或者 0 次。<br>
`+`--至少重复匹配一次。<br>
`*`--至少重复匹配 0 次。<br>

### 贪婪匹配

贪婪匹配只要满足匹配条件，会尽可能的匹配多的数据。

```
const ret = '123 1234 12345 123456'.match(/\d{2,5}/g)
// ['123', '1234', '12345', '12345']
console.log(ret)
```

### 惰性匹配

惰性匹配则是满足匹配条件，只需匹配最少量的数据就行.

```
const ret = '123 1234 12345 123456'.match(/\d{2,5}?/g)
// ['12', '12', '34', '12', '34', '12', '34', '56']
console.log(ret)

```

### 多选分支

多选分支需要借助括号来实现，**多个子模式满足任意一个就算匹配成功**，且会停止匹配，就像`或运算`一样，所以它默认就是`惰性匹配模式`，使用`|(管道符)`分隔各个模式。

```
// 示例一，从 goodbye 中匹配 good
const ret1 = 'goodbye'.match(/good|goodbye/g)
// ['good']
console.log(ret)

// 示例二，从 goodbye 中匹配 goodbye
const ret2 = 'goodbye'.match(/goodbye|good/g)
// ['goodbye']
console.log(ret)

```

## 位置匹配

### 开头结尾

`^`匹配字符串的开头位置，多行模式(m)下匹配每一行的开始位置

`$`匹配字符串的结束位置，多行模式(m)下匹配每一行的换行符(\n)前面的位置

### 边界

`\b`匹配单词边界，具体描述就是`\w和\W之间`的位置，也包括`\w和^之间`的位置，也包括`\w和$之间`的位置.

```
const ret = "[JS] Lesson_01.mp4".replace(/\b/g, '#')
// "[#JS#] #Lesson_01#.#mp4#"
console.log(ret)
```

`\B`非单词边界，即\b 之外的位置都是\B 能匹配到的位置。

```
const ret = "[JS] Lesson_01.mp4".replace(/\B/g, '#')
// "#[J#S]# L#e#s#s#o#n#_#0#1.m#p#4"
console.log(ret)
```

### 查找

#### 前向查找

`/(?=p)/`，p 是一个子模式，该正则表示取 p 前面的位置。

```
const ret = 'hello'.replace(/(?=l)/g, '#')
// 'he#l#lo
console.log(ret)
```

`/(?!p)/`是`/(?=p)/`的反义词，匹配非 p 前面的位置。

```
const ret = 'hello'.replace(/(?!l)/g, '#')
// '#h#ell#o'
console.log(ret)
```

#### 后向查找

`/(?<=p)/`，p 是一个子模式，该正则表示取 p 后面的位置。

```
const ret = 'hello'.replace(/(?<=l)/g, '#')
// 'hel#l#o
console.log(ret)
```

`/(?<!p)/`是`/(?<=p)/`的反义词，匹配非 p 后面的位置。

```
const ret = 'hello'.replace(/(?<!l)/g, '#')
// '#h#e#llo#'
console.log(ret)
```

## 括号

括号在正则表达式中的作用就是提供分组以便引用分组数据的能力；也可以理解为数学中括号的作用，将一组数据括起来，统一处理。<br>

### 分组结构

比如/a+/，只能匹配连续的 1 到 n 个 a，如果我要匹配连续的 1 到 n 个 ab 呢？这时候就需要用到括号的分组能力，将 ab 括起来看作一组，然后加上量词（统一处理），比如/(ab)+/。

### 分支结构

分支结构其实就是前面讲到的多选分支，形如/(p1|p2)/，p1 和 p2 是两个正则表达式。比如/My name is (abc|cdef)/g 可以匹配 'My name is abc' 和 'My name is cdef'。

### 引用分组

有两种引用数据的方式：<br>
1、API 引用，比如`RegExp.$1-99`。<br>

```
const reg = /(\d{4})-(\d{2})-(\d{2})/
const str = "2021-10-04"
// ['2021-10-04', '2021', '10', '04', index: 0, input: '2021-10-04', groups: undefined]
console.log(str.match(reg))

```

```
const reg = /(\d{4})-(\d{2})-(\d{2})/
const str = "2021-10-04"
// ['2021-10-04', '2021', '10', '04', index: 0, input: '2021-10-04', groups: undefined]
console.log(reg.exec(str))
```

```
const reg = /(\d{4})-(\d{2})-(\d{2})/
const str = "2021-10-04"
// 正则操作都行，比如 match、exec、test
reg.test(str)
// 2021
console.log(RegExp.$1)
// 10
console.log(RegExp.$2)
// 04
console.log(RegExp.$3)

```

```
const reg = /(\d{4})-(\d{2})-(\d{2})/g
// 2021-10-04 => 2021/10/04
const ret = '2021-10-04'.replace(reg, '$1/$2/$3')
// 2021/10/04
console.log(ret)
```

2、正则表达式引用，比如`\1到\99`，当然只能引用前面已经出现的分组，所以又叫反向引用。<br>
**注意**：如果反向引用的分组不存在，比如 /(\d)\2/，这里的 \2 会被转义然后匹配转义后的字符。

```

// 注意其中的 \1，它就是反向引用，在第二个分隔符位置通过反向引用来使用第一个分隔符
const reg = /\d{4}(-|\/|\.)\d{2}\1\d{2}/
// true
console.log(reg.test('2021-10-04'))
// true
console.log(reg.test('2021/10/04'))
// true
console.log(reg.test('2021.10.04'))
```

### 非捕获分组

之前的使用方式都会捕获匹配到的分组数据，并在之后使用，所以也叫捕获型分组。<br>

假如只想使用括号的原始功能 —— 分组，并不想在 API 或者正则的反向引用中使用捕获到的数据，则可以使用非捕获分组。<br>

非捕获分组的优点是提高性能、减少内存占用。<br>
语法：`/(?:p)/`，比如：/(?:ab)+/g

```
const reg = /(?:ab)+/g
reg.test('abc')
// 空
console.log(RegExp.$1)
// $1c，分组不存在，$1 被原样匹配了
console.log('abc'.replace(reg, '$1'))

```
